#version 430 core

#define TILE_SIZE 16
//layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform mat4 viewMatrix;

// struct PointLight {
	// vec4 pos;
	// vec4 colour;
	// float radius;
// };

struct PointLight {
  vec3 pos;
  float radius;
  vec4 colour;
};

struct TileAABB {
	vec4 min;
	vec4 max;
};

struct LightGrid {
	uint offset;
	uint count;
};

layout(std430, binding = 0) readonly buffer lightSSBO {
	PointLight pointLights[];
};

layout(std430, binding = 1) buffer gridSSBO {
	TileAABB tiles[];
};

layout(std430, binding = 2) buffer lightGridSSBO {
	LightGrid lightGrid[];
};

layout(std430, binding = 3) buffer globalLightIndexListSSBO {
	uint globalLightIndexList[];
};

layout(std430, binding = 4) buffer globalIndexCountSSBO {
	uint globalIndexLightCount;
};

uniform int noOfLights;
shared PointLight sharedLights[TILE_SIZE * TILE_SIZE];
//shared uint globalIndexLightCount;

bool sphereAABBIntersect(uint light, uint tile);
float sqDistPointAABB(vec3 point, uint tile);

void main() {
	globalIndexLightCount = 0;
	//uint threadCount = TILE_SIZE * TILE_SIZE;
	uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
	uint batchCount = (noOfLights + threadCount - 1) / threadCount;
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);

	//uint tileIndex = gl_WorkGroupID.y * tileNumber.x + gl_WorkGroupID.x;
	//uint tileIndex = gl_LocalInvocationIndex + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * gl_WorkGroupID.z;
	uint tileIndex = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x;
	
	// if (gl_LocalInvocationIndex == 0) {
		// uint offset = tileIndex * 50;
		// for (uint i = 0; i < 50; i++) {
			// globalLightIndexList[offset + i] = -1;
		// }
	// }
	barrier();

	uint visibleLightCount = 0;
	uint visibleLightIndices[50];

	for (uint i = 0; i < batchCount; ++i) {
		uint lightIndex = i * threadCount + gl_LocalInvocationIndex;

		if (lightIndex >= noOfLights) {
			break;
		}

	//	lightIndex = min(lightIndex, noOfLights);

		sharedLights[gl_LocalInvocationIndex] = pointLights[lightIndex];
		barrier();

		for (uint light = 0; light < threadCount; ++light) {
			//if (sphereAABBIntersect(light, tileIndex)) {
				visibleLightIndices[visibleLightCount] = i * threadCount + light;
				visibleLightCount += 1;
			//}
		}
	}

	barrier();

	uint offset = atomicAdd(globalIndexLightCount, visibleLightCount);

	for (uint i = 0; i < visibleLightCount; ++i) {
		globalLightIndexList[offset + i] = visibleLightIndices[i];
	}

	lightGrid[tileIndex].offset = offset;
	lightGrid[tileIndex].count = visibleLightCount;
}
// We know 16 is length. Max - min. Pythagoras?
//bool sphereAABBIntersect(uint light, uint tile) {
//	float radius = sharedLights[light].radius;
//	vec3 center = vec3(viewMatrix * sharedLights[light].position);
//	float distSq = sqDistPointAABB(center, tile);
//
//	return distSq <= (radius * radius);
//}

bool sphereAABBIntersect(uint light, uint tile) {
	float radius = sharedLights[light].radius;
	vec3 center = vec3(viewMatrix * vec4(sharedLights[light].pos, 0));
	//vec3 center = vec3(viewMatrix * sharedLights[light].pos);
	float sqDist = sqDistPointAABB(center, tile);

	return sqDist <= (radius * radius);
}

float sqDistPointAABB(vec3 point, uint tile) {
	float sqDist = 0.0;
	TileAABB currentTile = tiles[tile];
	tiles[tile].max[3] = tile;
	for (int i = 0; i < 3; ++i) {
		float v = point[i];
		if (v < currentTile.min[i]) {
			sqDist += (currentTile.min[i] - v) * (currentTile.min[i] - v);
		}
		if (v > currentTile.max[i]) {
			sqDist += (v - currentTile.max[i]) * (v - currentTile.max[i]);
		}
	}
	return sqDist;
}